{"version":3,"sources":["herb/impl.cljs"],"mappings":"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","names":["herb.impl/dev?","js/goog.DEBUG","herb.impl/convert-pseudo","pseudos","cljs.core.map","p__30383","vec__30384","cljs.core.nth","kw","p","cljs.core.keyword","herb.impl/convert-media","media","p__30387","vec__30388","query","style","garden.stylesheet.at_media","herb.impl/convert-supports","supports","p__30391","vec__30392","garden.stylesheet.at_supports","herb.impl/convert-vendors","vendors","cljs.core.mapv","cljs.core/name","herb.impl/resolve-style-fns","style-fns","sf","result","cljs.core/empty?","input","cljs.core/first","cljs.core/fn?","cljs.core.conj","cljs.core.apply","cljs.core/rest","cljs.core/coll?","style-fn","style-args","cljs.core.into","herb.impl/process-meta-xform","meta-type","cljs.core.comp","cljs.core/meta","cljs.core.filter","cljs.core/identity","herb.impl/extract-extended-styles","cljs.core/vector?","cljs.core/seq","styles","new-meta","herb.impl/extract-meta","convert-fn","G__30402","cljs.core/Keyword","js/Error","extracted","merged","G__30403","cljs.core/last","cljs.core/concat","cljs.core/merge","herb.impl/prepare-data","resolved-styles","herb.impl/sanitize","G__30404","clojure.string/replace","herb.impl/compose-selector","n","hsh","kind","hint","cljs.core._EQ_","and__4115__auto__","herb.impl/create-data-string","c","clojure.string.split","ns","cljs.core/str","cljs.core.interpose","cljs.core/butlast","sym","cljs.core.symbol","herb.impl/get-name","ns-name","name*","anon?","cname","cljs.core/not","cljs.core/demunge","var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","herb.impl/with-style!","seq30405","G__30406","cljs.core/next","G__30407","G__30408","G__30409","self__4723__auto__","fn-name","args","style-data","selector","cljs.core/hash","identifier","data-str","herb.runtime/inject-style!","cljs.core.subs"],"sourcesContent":["(ns herb.impl\n  (:require\n   [clojure.string :as str]\n   [herb.runtime :as runtime]\n   [garden.stylesheet :refer [at-media at-supports]]))\n\n(def dev? ^boolean js/goog.DEBUG)\n\n(defn- convert-pseudo\n  [pseudos]\n  (map\n   (fn [[kw p]]\n     [(keyword (str \"&\" kw)) p])\n   pseudos))\n\n(defn- convert-media\n  [media]\n  (map (fn [[query style]]\n         (at-media query [:& style]))\n       media))\n\n(defn- convert-supports\n  [supports]\n  (map (fn [[query style]]\n         (at-supports query [:& style]))\n       supports))\n\n(defn convert-vendors\n  [vendors]\n  (mapv name vendors)\n  #_(into []\n        (comp\n         (map name)\n         (distinct))\n        vendors))\n\n(defn- resolve-style-fns\n  \"Calls each function provided in a collection of style-fns. Input can take\n  multiple forms depending on how it got called from the consumer side either\n  using the macro directly or via extend meta data. Takes a collection of\n  `style-fns`  and returns a vector with the resolved style maps.\"\n  [style-fns]\n  (loop [sf style-fns\n         result []]\n    (if (empty? sf)\n      result\n      (let [input (first sf)]\n        (cond\n          (fn? input)\n          (conj result (apply input (rest sf)))\n\n          (and (coll? input) (fn? (first input)))\n          (let [style-fn (first input)\n                style-args (rest input)]\n            (recur\n             (rest sf)\n             (conj result (apply style-fn style-args))))\n          :else (recur\n                 (rest sf)\n                 (into result (resolve-style-fns input))))))))\n\n(defn- process-meta-xform\n  \"Return a transducer that pulls out a given meta type from a sequence and filter\n  out nil values\"\n  [meta-type]\n  (comp\n   (map meta)\n   (map meta-type)\n   (filter identity)))\n\n(defn- extract-extended-styles\n  \"Extract all the `:extend` meta, ensuring what we walk the entire tree, passing\n  each extend vector of style-fns to `resolve-style-fns` for resolution. Returns\n  vector of resolved styles\"\n  [style-fns]\n  (loop [sf style-fns\n         result []]\n    (cond\n\n      (fn? sf)\n      (recur [sf] result)\n\n      (and (vector? sf) (seq sf))\n      (let [styles (resolve-style-fns sf)\n            new-meta (into [] (process-meta-xform :extend) styles)]\n        (recur new-meta\n               (into styles result)))\n      :else result)))\n\n(defn- extract-meta\n  \"Takes a group of resolved styles and a meta type. Pull out each meta obj and\n  merge to prevent duplicates, finally convert to garden acceptable input and\n  return\"\n  [styles meta-type]\n  (let [convert-fn (case meta-type\n                     :media convert-media\n                     :supports convert-supports\n                     :prefix identity\n                     :vendors convert-vendors\n                     :pseudo convert-pseudo\n                     :combinators identity)\n        extracted (into [] (process-meta-xform meta-type) styles)]\n    (when (seq extracted)\n      (let [merged (case meta-type\n                     :prefix (last extracted)\n                     :vendors (apply concat extracted)\n                     (apply merge {} extracted))]\n        (convert-fn merged)))))\n\n\n(defn- prepare-data\n  \"Prepare `resolved-styles` so they can be passed to `garden.core/css` Merge\n  the styles to remove duplicate entries and ensuring precedence. Extract all\n  meta and return a final vector of styles including meta.\"\n  [resolved-styles]\n   {:style (apply merge {} resolved-styles)\n    :pseudo  (extract-meta resolved-styles :pseudo)\n    :vendors (extract-meta resolved-styles :vendors)\n    :prefix (extract-meta resolved-styles :prefix)\n    :supports (extract-meta resolved-styles :supports)\n    :media (extract-meta resolved-styles :media)\n    :combinators (extract-meta resolved-styles :combinators)})\n\n(defn- sanitize\n  \"Takes `input` and remove any non-valid characters\"\n  [input]\n  (when input\n    (cond\n      (keyword? input) (sanitize (name input))\n      :else (str/replace (str input) #\"[^A-Za-z0-9-_]\" \"_\"))))\n\n(defn- compose-selector\n  [n hsh kind hint]\n  (str (if (= kind :id) \"#\" \".\")\n       (sanitize n)\n       (when (and hint dev?) (str \"_\" (sanitize hint)))\n       \"_\" hsh))\n\n(defn- create-data-string\n  \"Create a fully qualified name string for use in the data-herb attr\"\n  [n]\n  (let [c (str/split n #\"/\")\n        ns (apply str (interpose \".\" (butlast c)))\n        sym (last c)]\n    (str (symbol ns sym))))\n\n(defn- get-name\n  [style-fn ns-name]\n  (let [name* (.-name style-fn)\n        anon? (empty? name*)\n        cname (cond\n                (and anon? (not dev?)) (str \"A-\")\n                (and dev? anon?) (str ns-name \"/\" \"anonymous\")\n                :else name*)]\n    (if dev? (demunge cname) cname)))\n\n(defn with-style!\n  \"Entry point for macros.\n  Takes an `opt` map as first argument, and currently only supports `:id true`\n  which appends an id identifier instead of a class to the DOM\"\n  [kind fn-name ns-name style-fn & args]\n  (let [name* (get-name style-fn ns-name)\n        resolved-styles (extract-extended-styles (into [style-fn] args))\n        style-data (prepare-data resolved-styles)\n        hint (:hint (-> resolved-styles last meta))\n        selector (compose-selector name* (hash style-data) kind hint)\n        identifier (sanitize name*)\n        data-str (when dev? (create-data-string name*))\n        result (runtime/inject-style! identifier [selector style-data] data-str)]\n        (if (= kind :style)\n          (:css result)\n          (subs selector 1))))\n"]}