{"version":3,"sources":["blackjack_cljs/game.cljs"],"mappings":"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","names":["var_args","G__48560","blackjack-cljs.game/queue","js/Error","cljs.core/PersistentQueue","coll","cljs.core.reduce","cljs.core/conj","blackjack-cljs.game/initial-state","iter__4529__auto__","s__48562","cljs.core/LazySeq","temp__5735__auto__","cljs.core/seq","xs__6292__auto__","cljs.core/first","iterys__4525__auto__","s__48564","cljs.core/chunked-seq?","c__4527__auto__","size__4528__auto__","cljs.core/count","b__48566","cljs.core/chunk-buffer","i__48565","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__48563","cljs.core/chunk-rest","cljs.core/cons","cljs.core/rest","fs__4526__auto__","cljs.core.concat","iter__48561","type","number","cljs.core/PersistentHashMap","cljs.core/shuffle","blackjack_cljs.game.queue","G__48568","blackjack-cljs.game/deal","state","contender","blackjack_cljs.game.deal","face-down?","card","cljs.core/peek","cljs.core.assoc","deal-helper","cljs.core.update","cljs.core/pop","blackjack-cljs.game/hit","blackjack-cljs.game/count-cards-helper","cards","p1__48569#","cljs.core.map","G__48570","acc","num","cljs.core.partial","cljs.core/+","cljs.core/vector?","cljs.core/second","cljs.core.remove","cljs.core/<","cljs.core.apply","cljs.core/max","blackjack-cljs.game/count-cards","cljs.core.get","blackjack-cljs.game/blackjack?","cljs.core._EQ_","blackjack-cljs.game/bust?","blackjack-cljs.game/face-up-cards","p1__48571#","cljs.core.mapv","blackjack-cljs.game/add-win","cljs.core/inc","blackjack-cljs.game/add-loss","blackjack-cljs.game/set-draw","blackjack-cljs.game/new-round","preserved-data","cljs.core/select-keys","cljs.core.merge","blackjack-cljs.game/initial-deal","new-state","blackjack-cljs.game/soft-17?","cljs.core/set","blackjack-cljs.game/lose-if-bust","blackjack-cljs.game/dealer-check","counter","dealer-counts","player-counts","G__48572","cljs.core/chunk-first"],"sourcesContent":["(ns blackjack-cljs.game\n  (:require [clojure.string :as s]\n            [cljs.core :refer [PersistentQueue]]))\n\n(defn queue\n  ([] (.-EMPTY PersistentQueue))\n  ([coll]\n   (reduce conj (.-EMPTY PersistentQueue)  coll)))\n\n(defn initial-state\n  \"Get a fresh initial state\"\n  []\n  {:wins      0\n   :losses    0\n   :has-won?  false\n   :has-lost? false\n   :draw?     false\n   :cards     (-> (for [type [:hearts :clubs :diamonds :spades]\n                        number [\\A 2 3 4 5 6 7 8 9 10 \\J \\Q \\K]]\n                    (hash-map :type type :number number :face-down? false))\n                  shuffle\n                  queue)\n   :round     0\n   :player    []\n   :dealer    []})\n\n(defn deal\n  \"Deal a card to a contender, optionally the card can be dealt face-down\"\n  ([state contender]\n   (deal state contender false))\n  ([state contender face-down?]\n   (let [card (-> state :cards peek (assoc :face-down? face-down?))\n         deal-helper (fn [state contender]\n                       (-> state\n                           (update :cards pop)\n                           (update contender conj card)))]\n     (deal-helper state contender))))\n\n(def hit deal)                                              ;; alias\n\n(defn count-cards-helper\n  [cards]\n  (->> cards\n       (map #(case (:number %) ;; map each card to it's value, the ace is mapped to the tuple [1 11]\n               (\\J \\Q \\K) 10\n               \\A [1 11]\n               (:number %)))\n       (reduce (fn [acc num]\n                 (cond\n                   ;; if a normal number, then add it to all possible results\n                   (number? num) (map (partial + num) acc)\n                   ;; if it's the Aces vector, then do the sum for both possible values 1 & 11\n                   (vector? num) (concat (map (partial + (first num)) acc)\n                                         (map (partial + (second num)) acc)))) [0])\n       (remove (partial < 21)) ;; filter out all possible values that would cause a bust\n       (apply max 0))) ;; finally, get the max of sums, if it's bust then 0 is returned\n\n(defn count-cards\n  \"Count the cards' values in the hand of a contender\n   The Aces will be counted as 1 or 11, being greedy but not bust\"\n  [state contender]\n  (count-cards-helper (get state contender)))\n\n(defn blackjack?\n  \"Check if the contender has a blackjack, try for both Ace values: 1 & 11\"\n  [state contender]\n  (= (count-cards state contender) 21))\n\n(defn bust?\n  \"Check if the contender went bust (cards' values exceed 21)\"\n  [state contender]\n  (zero? (count-cards state contender)))\n\n(defn face-up-cards\n  \"Flip all contender's cards to be face-up\"\n  [state contender]\n  (update state contender #(mapv (fn [card] (assoc card :face-down? false)) %)))\n\n(defn add-win [state]\n  (-> state\n      (update :wins inc)\n      (assoc :has-won? true)))\n\n(defn add-loss [state]\n  (-> state\n      (update :losses inc)\n      (assoc :has-lost? true)))\n\n(defn set-draw [state] (assoc state :draw? true))\n\n(defn new-round\n  \"Start new round, but keep track of the wins, losses and the round number\"\n  [state]\n  (let [preserved-data (-> (select-keys state [:wins :losses :round])\n                           (update :round inc))]\n    (merge (initial-state) preserved-data)))\n\n(defn initial-deal\n  \"\n  Dealer deals 1 card to the player and 1 card to himself\n  If the player has a blackjack then a win is added and a new round is started\n  Otherwise the turn is switched to the player\n  \"\n  [state]\n  (let [new-state (-> state\n                      (deal :player)\n                      (deal :dealer)\n                      (deal :player)\n                      (deal :dealer true))]\n    (if (blackjack? new-state :player)\n      (add-win new-state)\n      new-state)))\n\n(defn soft-17? [state contender]\n  (let [cards (get state contender)]\n    (= (set (map :number cards)) #{\\A 6})))\n\n(defn lose-if-bust\n  \"\n  Check to run after the player takes an action.\n  If gone bust add a loss to the score.\n  \"\n  [state]\n  (if (bust? state :player)\n    (add-loss state)\n    state))\n\n(defn dealer-check\n  [state]\n  (let [counter (partial count-cards state)\n        dealer-counts (counter :dealer)\n        player-counts (counter :player)]\n    ;; Check all possible combinations for card values that might contain aces\n    (cond\n      ;; It's a draw when dealer and player have the same count of card values but only if the dealer got more than 17\n      (and (= dealer-counts player-counts) (< 17 dealer-counts))\n      (set-draw state)                                      ;; Set the draw flag\n      (bust? state :dealer)\n      (add-win state)                                       ;; Dealer's bust, add a new win to player\n      ;; If cards' value of the dealer is less than 17, or he has a soft 17 then he must `hit`.\n      ;; A recursive call to this same function is made after the `hit` to run the checks again\n      (or (> 17 dealer-counts) (soft-17? state :dealer))\n      (-> state (hit :dealer) dealer-check)\n      ;; Compare the dealer's and player's card values\n      ;; The dealer stands if the values of his card exceeds or equals  17\n      (<= 17 dealer-counts)\n      (cond\n        (> player-counts dealer-counts) (add-win state)\n        (< player-counts dealer-counts) (add-loss state))\n      :else\n      (assert false \"The dealer must take an action\"))))\n\n"]}